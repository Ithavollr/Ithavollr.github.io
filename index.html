<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Retro Modern Site — Updated</title>
  <link rel="stylesheet" href="arcade.css">
</head>
<body>
  <header>Welcome to Iðavöllr</header>
  <h1>Download Client</h1>

  <div class="container">
    <div class="download-wrap">
      <a id="downloadBtn" class="download-btn" href="#" role="button" aria-label="Download Client">Download<br>Client</a>
    </div>

    <!-- sentinel: observed by IntersectionObserver; reveal parchment when it enters view -->
    <div id="sentinel" class="sentinel" aria-hidden="true"></div>

    <section id="parchment" class="parchment" aria-hidden="true">
      <h2>Release Notes & Lore</h2>
      <p>Read here the lore of our world...</p>
      <p>This site <i>should</i> adapt to system light/dark preference.</p>
      <p>Progressive enhancement: the reveal uses IntersectionObserver for reliability with a scroll-based fallback for older browsers.</p>
    </section>
  </div>

  <footer>© retro · Built with only HTML & CSS (+ tiny JS for theme & reveal)</footer>

  <script>
    /* Theme adaptation — CSS will handle most cases; keep a small JS listener as a fallback */
    (function(){
      function applyTheme(){
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          document.documentElement.setAttribute('data-theme','dark');
        } else {
          document.documentElement.removeAttribute('data-theme');
        }
      }
      applyTheme();
      if (window.matchMedia) window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', applyTheme);
    })();

    /* Scroll reveal using IntersectionObserver and a sentinel placed after the button.
       This is robust (works when layout changes) and keeps the "reveal when you pass the button" behaviour. */
    (function(){
      const sentinel = document.getElementById('sentinel');
      const parchment = document.getElementById('parchment');

      if (!sentinel || !parchment) return;

      if ('IntersectionObserver' in window) {
        const io = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              parchment.classList.add('visible');
              parchment.setAttribute('aria-hidden','false');
              io.disconnect(); // reveal only once
            }
          });
        }, { root: null, threshold: 0.01 });
        io.observe(sentinel);
      } else {
        // fallback for older browsers: simple scroll listener that triggers when button's bottom is above viewport
        const btn = document.getElementById('downloadBtn');
        function fallback(){
          const rect = btn.getBoundingClientRect();
          if (rect.bottom < 10) {
            parchment.classList.add('visible');
            parchment.setAttribute('aria-hidden','false');
            window.removeEventListener('scroll', fallback);
          }
        }
        window.addEventListener('scroll', fallback);
        fallback();
      }
    })();
  </script>
</body>
</html>
